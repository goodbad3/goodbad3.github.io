{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"2","date":"2020-01-28T13:03:47.000Z","updated":"2020-01-28T13:03:47.084Z","comments":true,"path":"2/index-1.html","permalink":"http://yoursite.com/2/index-1.html","excerpt":"","text":""},{"title":"2","date":"2020-01-28T13:03:42.000Z","updated":"2020-01-28T13:03:42.426Z","comments":true,"path":"2/index.html","permalink":"http://yoursite.com/2/index.html","excerpt":"","text":""},{"title":"2ll","date":"2020-01-28T13:03:55.000Z","updated":"2020-01-28T13:03:55.489Z","comments":true,"path":"2ll/index.html","permalink":"http://yoursite.com/2ll/index.html","excerpt":"","text":""}],"posts":[{"title":"python进阶 推导式 Comprehension","slug":"python进阶-推导式-Comprehension","date":"2020-01-29T08:16:19.000Z","updated":"2020-01-29T08:16:19.611Z","comments":true,"path":"2020/01/29/python进阶-推导式-Comprehension/","link":"","permalink":"http://yoursite.com/2020/01/29/python%E8%BF%9B%E9%98%B6-%E6%8E%A8%E5%AF%BC%E5%BC%8F-Comprehension/","excerpt":"","text":"","categories":[],"tags":[],"author":"John Doe"},{"title":"python进阶 枚举 Enumerate","slug":"python进阶-枚举-Enumerate","date":"2020-01-29T08:12:51.000Z","updated":"2020-01-29T08:14:49.879Z","comments":true,"path":"2020/01/29/python进阶-枚举-Enumerate/","link":"","permalink":"http://yoursite.com/2020/01/29/python%E8%BF%9B%E9%98%B6-%E6%9E%9A%E4%B8%BE-Enumerate/","excerpt":"","text":"枚举枚举(enumerate)是Python内置函数。它的用处很难在简单的一行中说明，但是大多数的新人，甚至一些高级程序员都没有意识到它。 它允许我们遍历数据并自动计数， 下面是一个例子： 12for counter, value in enumerate(some_list): print(counter, value) 不只如此，enumerate也接受一些可选参数，这使它更有用。 123456789my_list = ['apple', 'banana', 'grapes', 'pear']for c, value in enumerate(my_list, 1): print(c, value)# 输出:(1, 'apple')(2, 'banana')(3, 'grapes')(4, 'pear') 上面这个可选参数允许我们定制从哪个数字开始枚举。你还可以用来创建包含索引的元组列表，例如： 1234my_list = ['apple', 'banana', 'grapes', 'pear']counter_list = list(enumerate(my_list, 1))print(counter_list)# 输出: [(1, 'apple'), (2, 'banana'), (3, 'grapes'), (4, 'pear')]","categories":[{"name":"python进阶教程","slug":"python进阶教程","permalink":"http://yoursite.com/categories/python%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/"}],"tags":[],"author":"John Doe"},{"title":"python进阶 lambda表达式","slug":"python进阶-lambda表达式","date":"2020-01-29T08:00:34.000Z","updated":"2020-01-29T08:06:33.959Z","comments":true,"path":"2020/01/29/python进阶-lambda表达式/","link":"","permalink":"http://yoursite.com/2020/01/29/python%E8%BF%9B%E9%98%B6-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"17. lambda表达式lambda表达式是一行函数。它们在其他语言中也被称为匿名函数。如果你不想在程序中对一个函数使用两次，你也许会想用lambda表达式，它们和普通的函数完全一样。 原型 1lambda 参数:操作(参数) 例子 1234add = lambda x, y: x + yprint(add(3, 5))# Output: 8 这还有一些lambda表达式的应用案例，可以在一些特殊情况下使用： 列表排序 12345a = [(1, 2), (4, 1), (9, 10), (13, -3)]a.sort(key=lambda x: x[1])print(a)# Output: [(13, -3), (4, 1), (1, 2), (9, 10)] 列表并行排序 123data = zip(list1, list2)data.sort()list1, list2 = map(lambda t: list(t), zip(*data))","categories":[{"name":"python进阶教程","slug":"python进阶教程","permalink":"http://yoursite.com/categories/python%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/"}],"tags":[],"author":"John Doe"},{"title":"python进阶 Map，Filter 和 Reduce","slug":"python进阶- Map，Filter 和 Reduce","date":"2020-01-29T07:46:43.671Z","updated":"2020-01-29T07:59:42.400Z","comments":true,"path":"2020/01/29/python进阶- Map，Filter 和 Reduce/","link":"","permalink":"http://yoursite.com/2020/01/29/python%E8%BF%9B%E9%98%B6-%20Map%EF%BC%8CFilter%20%E5%92%8C%20Reduce/","excerpt":"","text":"Map，Filter 和 ReduceMap，Filter 和 Reduce 三个函数能为函数式编程提供便利。我们会通过实例一个一个讨论并理解它们。 MapMap会将一个函数映射到一个输入列表的所有元素上。这是它的规范： 规范 1map(function_to_apply, list_of_inputs) 大多数时候，我们要把列表中所有元素一个个地传递给一个函数，并收集输出。比方说： 1234items = [1, 2, 3, 4, 5]squared = []for i in items: squared.append(i**2) Map可以让我们用一种简单而漂亮得多的方式来实现。就是这样： 12items = [1, 2, 3, 4, 5]squared = list(map(lambda x: x**2, items)) 大多数时候，我们使用匿名函数(lambdas)来配合map, 所以我在上面也是这么做的。 不仅用于一列表的输入， 我们甚至可以用于一列表的函数！ 12345678910111213141516171819def multiply(x): return (x*x)def add(x): return (x+x)funcs = [multiply, add]for i in range(5): value = map(lambda x: x(i), funcs) print(list(value)) # 译者注：上面print时，加了list转换，是为了python2/3的兼容性 # 在python2中map直接返回列表，但在python3中返回迭代器 # 因此为了兼容python3, 需要list转换一下# Output:# [0, 0]# [1, 2]# [4, 4]# [9, 6]# [16, 8] Filter顾名思义，filter过滤列表中的元素，并且返回一个由所有符合要求的元素所构成的列表，符合要求即函数映射到该元素时返回值为True. 这里是一个简短的例子： 12345678number_list = range(-5, 5)less_than_zero = filter(lambda x: x &lt; 0, number_list)print(list(less_than_zero)) # 译者注：上面print时，加了list转换，是为了python2/3的兼容性# 在python2中filter直接返回列表，但在python3中返回迭代器# 因此为了兼容python3, 需要list转换一下# Output: [-5, -4, -3, -2, -1] 这个filter类似于一个for循环，但它是一个内置函数，并且更快。 注意：如果map和filter对你来说看起来并不优雅的话，那么你可以看看另外一章：列表/字典/元组推导式。 译者注：大部分情况下推导式的可读性更好 Reduce当需要对一个列表进行一些计算并返回结果时，Reduce 是个非常有用的函数。举个例子，当你需要计算一个整数列表的乘积时。 通常在 python 中你可能会使用基本的 for 循环来完成这个任务。 现在我们来试试 reduce： 1234from functools import reduceproduct &#x3D; reduce( (lambda x, y: x * y), [1, 2, 3, 4] )# Output: 24","categories":[{"name":"python进阶教程","slug":"python进阶教程","permalink":"http://yoursite.com/categories/python%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/"}],"tags":[],"author":"刘竟"},{"title":"python进阶 Generators","slug":"python进阶-Generators","date":"2020-01-28T13:26:53.222Z","updated":"2020-01-29T01:17:42.406Z","comments":true,"path":"2020/01/28/python进阶-Generators/","link":"","permalink":"http://yoursite.com/2020/01/28/python%E8%BF%9B%E9%98%B6-Generators/","excerpt":"","text":"生成器（Generators）首先我们要理解迭代器(iterators)。根据维基百科，迭代器是一个让程序员可以遍历一个容器（特别是列表）的对象。然而，一个迭代器在遍历并读取一个容器的数据元素时，并不会执行一个迭代。你可能有点晕了，那我们来个慢动作。换句话说这里有三个部分： 可迭代对象(Iterable) 迭代器(Iterator) 迭代(Iteration) 上面这些部分互相联系。我们会先各个击破来讨论他们，然后再讨论生成器(generators). 可迭代对象(Iterable)Python中任意的对象，只要它定义了可以返回一个迭代器的__iter__方法，或者定义了可以支持下标索引的__getitem__方法(这些双下划线方法会在其他章节中全面解释)，那么它就是一个可迭代对象。简单说，可迭代对象就是能提供迭代器的任意对象。那迭代器又是什么呢？ 迭代器(Iterator)任意对象，只要定义了next(Python2) 或者__next__方法，它就是一个迭代器。就这么简单。现在我们来理解迭代(iteration) 迭代(Iteration)用简单的话讲，它就是从某个地方（比如一个列表）取出一个元素的过程。当我们使用一个循环来遍历某个东西时，这个过程本身就叫迭代。现在既然我们有了这些术语的基本理解，那我们开始理解生成器吧。 生成器(Generators)生成器也是一种迭代器，但是你只能对其迭代一次。这是因为它们并没有把所有的值存在内存中，而是在运行时生成值。你通过遍历来使用它们，要么用一个“for”循环，要么将它们传递给任意可以进行迭代的函数和结构。大多数时候生成器是以函数来实现的。然而，它们并不返回一个值，而是yield(暂且译作“生出”)一个值。这里有个生成器函数的简单例子： 1234567891011121314151617def generator_function(): for i in range(10): yield ifor item in generator_function(): print(item)# Output: 0# 1# 2# 3# 4# 5# 6# 7# 8# 9 这个案例并不是非常实用。生成器最佳应用场景是：你不想同一时间将所有计算出来的大量结果集分配到内存当中，特别是结果集里还包含循环。 译者注：这样做会消耗大量资源 许多Python 2里的标准库函数都会返回列表，而Python 3都修改成了返回生成器，因为生成器占用更少的资源。 下面是一个计算斐波那契数列的生成器： 12345678910# generator versiondef fibon(n): a = b = 1 for i in range(n): yield a a, b = b, a + bNow we can use it like this:for x in fibon(1000000): print(x) 用这种方式，我们可以不用担心它会使用大量资源。然而，之前如果我们这样来实现的话： 1234567def fibon(n): a = b = 1 result = [] for i in range(n): result.append(a) a, b = b, a + b return result 这也许会在计算很大的输入参数时，用尽所有的资源。我们已经讨论过生成器使用一次迭代，但我们并没有测试过。在测试前你需要再知道一个Python内置函数：next()。它允许我们获取一个序列的下一个元素。那我们来验证下我们的理解： 123456789101112131415def generator_function(): for i in range(3): yield igen = generator_function()print(next(gen))# Output: 0print(next(gen))# Output: 1print(next(gen))# Output: 2print(next(gen))# Output: Traceback (most recent call last):# File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;# StopIteration 我们可以看到，在yield掉所有的值后，next()触发了一个StopIteration的异常。基本上这个异常告诉我们，所有的值都已经被yield完了。你也许会奇怪，为什么我们在使用for循环时没有这个异常呢？啊哈，答案很简单。for循环会自动捕捉到这个异常并停止调用next()。你知不知道Python中一些内置数据类型也支持迭代哦？我们这就去看看： 12345my_string = \"Yasoob\"next(my_string)# Output: Traceback (most recent call last):# File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;# TypeError: str object is not an iterator 好吧，这不是我们预期的。这个异常说那个str对象不是一个迭代器。对，就是这样！它是一个可迭代对象，而不是一个迭代器。这意味着它支持迭代，但我们不能直接对其进行迭代操作。那我们怎样才能对它实施迭代呢？是时候学习下另一个内置函数，iter。它将根据一个可迭代对象返回一个迭代器对象。这里是我们如何使用它： 1234my_string = \"Yasoob\"my_iter = iter(my_string)next(my_iter)# Output: 'Y' 现在好多啦。我肯定你已经爱上了学习生成器。一定要记住，想要完全掌握这个概念，你只有使用它。确保你按照这个模式，并在生成器对你有意义的任何时候都使用它。你绝对不会失望的！","categories":[{"name":"python进阶教程","slug":"python进阶教程","permalink":"http://yoursite.com/categories/python%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/"}],"tags":[],"author":"刘竟"},{"title":"python进阶 Debugging","slug":"python进阶-Debugging","date":"2020-01-28T13:23:12.975Z","updated":"2020-01-28T13:25:44.489Z","comments":true,"path":"2020/01/28/python进阶-Debugging/","link":"","permalink":"http://yoursite.com/2020/01/28/python%E8%BF%9B%E9%98%B6-Debugging/","excerpt":"","text":"调试（Debugging）利用好调试，能大大提高你捕捉代码Bug的。大部分新人忽略了Python debugger(pdb)的重要性。 在这个章节我只会告诉你一些重要的命令，你可以从官方文档中学习到更多。 译者注，参考：https://docs.python.org/2/library/pdb.htmlOr https://docs.python.org/3/library/pdb.html 从命令行运行你可以在命令行使用Python debugger运行一个脚本， 举个例子： 1$ python -m pdb my_script.py 这会触发debugger在脚本第一行指令处停止执行。这在脚本很短时会很有帮助。你可以通过(Pdb)模式接着查看变量信息，并且逐行调试。 从脚本内部运行同时，你也可以在脚本内部设置断点，这样就可以在某些特定点查看变量信息和各种执行时信息了。这里将使用pdb.set_trace()方法来实现。举个例子： 1234567import pdbdef make_bread(): pdb.set_trace() return \"I don't have time\"print(make_bread()) 试下保存上面的脚本后运行之。你会在运行时马上进入debugger模式。现在是时候了解下debugger模式下的一些命令了。 #####命令列表： c: 继续执行 w: 显示当前正在执行的代码行的上下文信息 a: 打印当前函数的参数列表 s: 执行当前代码行，并停在第一个能停的地方（相当于单步进入） n: 继续执行到当前函数的下一行，或者当前行直接返回（单步跳过） 单步跳过（next）和单步进入（step）的区别在于， 单步进入会进入当前行调用的函数内部并停在里面， 而单步跳过会（几乎）全速执行完当前行调用的函数，并停在当前函数的下一行。 pdb真的是一个很方便的功能，上面仅列举少量用法，更多的命令强烈推荐你去看官方文档。","categories":[{"name":"python进阶教程","slug":"python进阶教程","permalink":"http://yoursite.com/categories/python%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/"}],"tags":[],"author":"刘竟"},{"title":"python进阶   args_kwargs","slug":"python进阶-args_kwargs","date":"2020-01-28T13:05:00.000Z","updated":"2020-01-28T13:16:59.368Z","comments":true,"path":"2020/01/28/python进阶-args_kwargs/","link":"","permalink":"http://yoursite.com/2020/01/28/python%E8%BF%9B%E9%98%B6-args_kwargs/","excerpt":"","text":"*args 和 **kwargs我观察到，大部分新的Python程序员都需要花上大量时间理解清楚 *args 和**kwargs这两个魔法变量。那么它们到底是什么? 首先让我告诉你, 其实并不是必须写成*args 和**kwargs。 只有变量前面的 *(星号)才是必须的. 你也可以写成*var 和**vars. 而写成*args 和**kwargs只是一个通俗的命名约定。 那就让我们先看一下*args吧。 *args 的用法啊！*args 和 **kwargs 主要用于函数定义。 你可以将不定数量的参数传递给一个函数。这里的不定的意思是：预先并不知道, 函数使用者会传递多少个参数给你, 所以在这个场景下使用这两个关键字。 *args 是用来发送一个非键值对的可变数量的参数列表给一个函数.这里有个例子帮你理解这个概念: 123456def test_var_args(f_arg, *argv): print(\"first normal arg:\", f_arg) for arg in argv: print(\"another arg through *argv:\", arg)test_var_args('yasoob', 'python', 'eggs', 'test') 这会产生如下输出: 1234first normal arg: yasoobanother arg through *argv: pythonanother arg through *argv: eggsanother arg through *argv: test 我希望这解决了你所有的困惑. 那接下来让我们谈谈 **kwargs **kwargs 的用法啊！**kwargs 允许你将不定长度的键值对, 作为参数传递给一个函数。 如果你想要在一个函数里处理带名字的参数, 你应该使用**kwargs。 这里有个让你上手的例子: 1234567def greet_me(**kwargs): for key, value in kwargs.items(): print(\"&#123;0&#125; == &#123;1&#125;\".format(key, value))&gt;&gt;&gt; greet_me(name=\"yasoob\")name == yasoob 现在你可以看出我们怎样在一个函数里, 处理了一个键值对参数了。 这就是**kwargs的基础, 而且你可以看出它有多么管用。 接下来让我们谈谈，你怎样使用*args 和 **kwargs来调用一个参数为列表或者字典的函数。 使用 *args 和 **kwargs 来调用函数那现在我们将看到怎样使用*args和**kwargs 来调用一个函数。 假设，你有这样一个小函数： 1234def test_args_kwargs(arg1, arg2, arg3): print(\"arg1:\", arg1) print(\"arg2:\", arg2) print(\"arg3:\", arg3) 你可以使用*args或**kwargs来给这个小函数传递参数。下面是怎样做： 12345678910111213# 首先使用 *args&gt;&gt;&gt; args = (\"two\", 3, 5)&gt;&gt;&gt; test_args_kwargs(*args)arg1: twoarg2: 3arg3: 5# 现在使用 **kwargs:&gt;&gt;&gt; kwargs = &#123;\"arg3\": 3, \"arg2\": \"two\", \"arg1\": 5&#125;&gt;&gt;&gt; test_args_kwargs(**kwargs)arg1: 5arg2: twoarg3: 3 标准参数与*args、**kwargs在使用时的顺序那么如果你想在函数里同时使用所有这三种参数， 顺序是这样的： 1some_func(fargs, *args, **kwargs) 什么时候使用它们？这还真的要看你的需求而定。 最常见的用例是在写函数装饰器的时候（会在另一章里讨论）。 此外它也可以用来做猴子补丁(monkey patching)。猴子补丁的意思是在程序运行时(runtime)修改某些代码。 打个比方，你有一个类，里面有个叫get_info的函数会调用一个API并返回相应的数据。如果我们想测试它，可以把API调用替换成一些测试数据。例如： 123456import someclassdef get_info(self, *args): return \"Test data\"someclass.get_info = get_info 我敢肯定你也可以想象到一些其他的用例。","categories":[{"name":"python进阶教程","slug":"python进阶教程","permalink":"http://yoursite.com/categories/python%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/"}],"tags":[],"author":"刘竟"},{"title":"2010 年全国硕士研究生入学统一考试(一、选择题) ","slug":"2010-年全国硕士研究生入学统一考试","date":"2020-01-28T00:46:00.000Z","updated":"2020-01-28T06:05:07.045Z","comments":true,"path":"2020/01/28/2010-年全国硕士研究生入学统一考试/","link":"","permalink":"http://yoursite.com/2020/01/28/2010-%E5%B9%B4%E5%85%A8%E5%9B%BD%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E7%BB%9F%E4%B8%80%E8%80%83%E8%AF%95/","excerpt":"","text":"数学一试题 一、选择题 https://www.bilibili.com/video/av16328731/","categories":[],"tags":[],"author":"John Doe"},{"title":"python第3章","slug":"python3","date":"2020-01-21T07:26:00.000Z","updated":"2020-02-01T07:02:18.170Z","comments":true,"path":"2020/01/21/python3/","link":"","permalink":"http://yoursite.com/2020/01/21/python3/","excerpt":"","text":"代码3-1 使用describe()方法即可查看数据的基本情况1234import pandas as pdcatering_sale = '../data/catering_sale.xls' # 餐饮数据data = pd.read_excel(catering_sale, index_col = u'日期') # 读取数据，指定“日期”列为索引列print(data.describe()) catering_sale.xls样式图片: 代码3-3 捞起生鱼片的季度销售情况频率分布直方图12345678910111213141516171819202122# 代码3-3 捞起生鱼片的季度销售情况import pandas as pdimport numpy as npcatering_sale = '../data/catering_fish_congee.xls' # 餐饮数据data = pd.read_excel(catering_sale,names=['d','sale']) bins = [0,500,1000,1500,2000,2500,3000,3500,4000]labels = ['[0,500)','[500,1000)','[1000,1500)','[1500,2000)', '[2000,2500)','[2500,3000)','[3000,3500)','[3500,4000)'] data['sale分层'] = pd.cut(data.sale, bins, labels=labels)aggResult = data.groupby(by=['sale分层'])['sale'].agg(sale=np.size)pAggResult = round(aggResult/aggResult.sum(), 2)import matplotlib.pyplot as pltplt.figure(figsize=(10,6)) # 设置图框大小尺寸pAggResult['sale'].plot(kind='bar',width=0.8,fontsize=10) # 绘制频率直方图plt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.title('季度销售额频率分布直方图',fontsize=20)plt.show() catering_fish_congee.xls样式图片: 代码3-4 不同菜品在某段时间的销售量的分布情况1234import pandas as pdimport matplotlib.pyplot as pltcatering_dish_profit = '../data/catering_dish_profit.xls' # 餐饮数据data = pd.read_excel(catering_dish_profit) catering_dish_profit.xls样式图片: 绘制饼图12345678x = data['盈利']labels = data['菜品名']plt.figure(figsize = (8, 6)) # 设置画布大小plt.pie(x,labels=labels) # 绘制饼图plt.rcParams['font.sans-serif'] = 'SimHei'plt.title('菜品销售量分布（饼图）') # 设置标题plt.axis('equal')plt.show() 绘制条形图123456789x = data['菜品名']y = data['盈利']plt.figure(figsize = (8, 4)) # 设置画布大小plt.bar(x,y)plt.rcParams['font.sans-serif'] = 'SimHei'plt.xlabel('菜品') # 设置x轴标题plt.ylabel('销量') # 设置y轴标题plt.title('菜品销售量分布（条形图）') # 设置标题plt.show() # 展示图片 代码3-5 不同部门在各月份的销售对比情况##部门之间销售金额比较 1234567891011import pandas as pdimport matplotlib.pyplot as pltdata=pd.read_excel(\"../data/dish_sale.xls\")plt.figure(figsize=(8, 4))plt.plot(data['月份'], data['A部门'], color='green', label='A部门',marker='o')plt.plot(data['月份'], data['B部门'], color='red', label='B部门',marker='s')plt.plot(data['月份'], data['C部门'], color='skyblue', label='C部门',marker='x')plt.legend() # 显示图例plt.ylabel('销售额（万元）')plt.rcParams['font.sans-serif'] = 'SimHei'plt.show() dish_sale.xls样式图片: B部门各年份之间销售金额的比较12345678data=pd.read_excel(\"../data/dish_sale_b.xls\")plt.figure(figsize=(8, 4))plt.plot(data['月份'], data['2012年'], color='green', label='2012年',marker='o')plt.plot(data['月份'], data['2013年'], color='red', label='2013年',marker='s')plt.plot(data['月份'], data['2014年'], color='skyblue', label='2014年',marker='x')plt.legend() # 显示图例plt.ylabel('销售额（万元）')plt.show() dish_sale_b.xls样式图片: 代码3-7 某单位日用电量预测分析折线图 12345678910111213141516171819import pandas as pdimport matplotlib.pyplot as pltdf_normal = pd.read_csv(\"../data/user.csv\")plt.figure(figsize=(8,4))plt.plot(df_normal[\"Date\"],df_normal[\"Eletricity\"])plt.xlabel(\"日期\")plt.ylabel(\"每日电量\")# 设置x轴刻度间隔x_major_locator = plt.MultipleLocator(7)ax = plt.gca()ax.xaxis.set_major_locator(x_major_locator)plt.title(\"正常用户电量趋势\")plt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.show() # 展示图片 窃电用户用电趋势分析123456789101112df_steal = pd.read_csv(\"../data/Steal user.csv\")plt.figure(figsize=(10, 9))plt.plot(df_steal[\"Date\"],df_steal[\"Eletricity\"])plt.xlabel(\"日期\")plt.ylabel(\"每日电量\")# 设置x轴刻度间隔x_major_locator = plt.MultipleLocator(7)ax = plt.gca()ax.xaxis.set_major_locator(x_major_locator)plt.title(\"窃电用户电量趋势\")plt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.show() # 展示图片 代码3-8 菜品盈利帕累托图条形图 123456789101112131415# 菜品盈利数据 帕累托图import pandas as pd# 初始化参数dish_profit = '../data/catering_dish_profit.xls' # 餐饮菜品盈利数据data = pd.read_excel(dish_profit, index_col = u'菜品名')data = data[u'盈利']data.sort_values(ascending = False)#降序import matplotlib.pyplot as plt # 导入图像库plt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号plt.figure()data.plot(kind='bar')plt.ylabel(u'盈利（元）') 1234567data.plot(kind='bar')plt.ylabel(u'盈利（元）')p = 1.0*data.cumsum()/data.sum()p.plot(color = 'r', secondary_y = True, style = '-o',linewidth = 2)plt.annotate(format(p[6], '.4%'), xy = (6, p[6]), xytext=(6*0.9, p[6]*0.9), arrowprops=dict(arrowstyle=\"-&gt;\", connectionstyle=\"arc3,rad=.2\")) # 添加注释，即85%处的标记。这里包括了指定箭头样式。plt.ylabel(u'盈利（比例）')plt.show() 代码3-17 绘制饼图1234567891011import matplotlib.pyplot as plt# The slices will be ordered and plotted counter-clockwise.labels = 'Frogs', 'Hogs', 'Dogs', 'Logs' # 定义标签sizes = [15, 30, 45, 10] # 每一块的比例colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral'] # 每一块的颜色explode = (0, 0.1, 0, 0) # 突出显示，这里仅仅突出显示第二块（即'Hogs'）plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', shadow=True, startangle=90)plt.axis('equal') # 显示为圆（避免比例压缩为椭圆）plt.show() 代码3-18 绘制二维条形直方图12345import matplotlib.pyplot as pltimport numpy as npx = np.random.randn(1000) # 1000个服从正态分布的随机数plt.hist(x, 10) # 分成10组进行绘制直方图plt.show()","categories":[{"name":"数据分析与挖掘","slug":"数据分析与挖掘","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/"}],"tags":[],"author":"刘竟"},{"title":"python工具","slug":"python工具","date":"2020-01-20T12:51:00.000Z","updated":"2020-01-31T08:48:18.800Z","comments":true,"path":"2020/01/20/python工具/","link":"","permalink":"http://yoursite.com/2020/01/20/python%E5%B7%A5%E5%85%B7/","excerpt":"","text":"numpy123456789101112# -*- coding: utf-8 -*-import numpy as np # 一般以np作为numpy的别名a = np.array([2, 0, 1, 5]) # 创建数组print(a) # 输出数组print(a[:3]) # 引用前三个数字（切片）print(a.min()) # 输出a的最小值a.sort() # 将a的元素从小到大排序，此操作直接修改a，因此这时候a为[0, 1, 2, 5]b = np.array([[1, 2, 3], [4, 5, 6]]) # 创建二维数组print(b * b) # 输出数组的平方阵，即[[1, 4, 9], [16, 25, 36]] Matplotlib123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf-8 -*-import numpy as npimport matplotlib.pyplot as plt # 导入Matplotlibplt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号x = np.linspace(0, 10, 1000) # 作图的变量自变量,0到10分成1000份，含有0和10(含后面)y = np.sin(x) + 1 # 因变量yz = np.cos(x**2) + 1 # 因变量zplt.figure(figsize=(8, 4)) # 设置图像大小plt.plot(x, y, label='$\\sin x+1$', color='red', linewidth=2) # 作图，设置标签、线条颜色、线条大小plt.plot(x, z, 'b--', label='$\\cos x^2+1$') # 作图，设置标签、线条类型plt.xlabel('Time(s) x轴') # x轴名称plt.ylabel('Volt y轴') # y轴名称plt.title('A Simple Example 图') # 标题plt.ylim(0, 2.2) # 显示的y轴范围plt.xlim(0, 11) # 显示的x轴范围plt.legend() # 显示图例plt.show() # 显示作图结果 Pandas12345678910111213# -*- coding: utf-8 -*-import pandas as pd # 通常用pd作为pandas的别名。s = pd.Series([1, 2, 3], index=['a', 'b', 'c']) # 创建一个序列sd = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=['a', 'b', 'c']) # 创建一个表d2 = pd.DataFrame(s) # 也可以用已有的序列来创建表格d.head() # 预览前5行数据","categories":[{"name":"数据分析与挖掘","slug":"数据分析与挖掘","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/"}],"tags":[],"author":"刘竟"},{"title":"第1章  AutoCAD2007入门","slug":"第1章-AutoCAD2007入门","date":"2020-01-13T14:53:00.000Z","updated":"2020-01-13T15:56:49.196Z","comments":true,"path":"2020/01/13/第1章-AutoCAD2007入门/","link":"","permalink":"http://yoursite.com/2020/01/13/%E7%AC%AC1%E7%AB%A0-AutoCAD2007%E5%85%A5%E9%97%A8/","excerpt":"","text":"综合实例——AutoCAD绘图范例","categories":[],"tags":[{"name":"cad","slug":"cad","permalink":"http://yoursite.com/tags/cad/"}],"author":"John Doe"}]}